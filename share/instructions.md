# Note

The radii of the fitted ellipsoid surface are arranged based on the smallest rotation angle of the ellipsoid axes, deviated from the defined reference frame, along its axis of rotation containing its approximate center. 

This arrangement also applies to the sequence of the eigenvalues and their corresponding eigenvectors. Consequently, the transpose of the eigenvectors' matrix from `*evec_column_p`, generated by the function
```cpp
Parameters ellipsoid::fit(..., Eigen::Vector3d* eval_p, Eigen::Matrix3d* evec_column_p, ...);
```
can be used as a rotation matrix to rotate the fitted ellipsoid to the nearest non-rotated ellipsoid, in term of rotation angle.

<details>
  <summary>Mathematical Details</summary>

From the C++ function above, suppose `*eval_p` contains $[e_0\ e_1\ e_2]^T$, and let its diagonal matrix `eval_p->asDiagonal()` denoted as $E$. Meanwhile, let `evec_column_p->transpose()` be denoted as $R$. 

Consider the inputs be $d_{in}=[x_{in}\ y_{in}\ z_{in}]^T$, while the outputs produced from rotating the inputs be $d_{out}=[x_{out}\ y_{out}\ z_{out}]^T$. The relationship between these vectors is given by:

$$e_0\ x_{out}^2+e_1\ y_{out}^2+e_2\ z_{out}^2 = d_{in}^T R^T E\ R\ d_{in}$$

Hence, the rotation from $d_{in}$ to $d_{out}$ is performed using
$d_{out} = R\ d_{in}$ or  
```cpp
...
Eigen::Vector3d d_in; // Inputs
Eigen::Matrix3d R = evec_column_p->transpose();

// Perform the multiplication d_out = R * d_in
Eigen::Vector3d d_out = R * d_in;
...
```

Additionally, the transformation from the fitted ellipsoid to a unit sphere can be achieved using 
$d_{out} = \sqrt{E} R\ d_{in}$, or

```cpp
...
Eigen::Vector3d d_in; // Inputs
Eigen::Matrix3d R = evec_column_p->transpose();
Eigen::Matrix3d sqrt_E = eval_p->cwiseSqrt().asDiagonal();

// Perform sphere mapping d_out = E^(0.5) * R * d_in
Eigen::Vector3d d_out = sqrt_E * R * d_in;
...
```
 This process involves first rotating the inputs, followed by scaling them.
</details>


## Warning

If any of the radii results in a 'NaN' value, it indicates that the fitted surface is a hyperboloid, not an ellipsoid.

Possible causes include:

1. Incomplete coverage of the surface points in the input data.
2. Numerical errors during the least square minimization in the fitting process.